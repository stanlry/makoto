package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path/filepath"
)

const collectionFilename = "collection.go"

func GenerateStringCollection(path string) {
	fmt.Println("Collect migration scripts:")

	buffer := bytes.NewBuffer(nil)
	fmt.Fprint(buffer, `// this is generated by makoto cli, do not modify this file.
package migration

import "github.com/cororoGrap/makoto"

func GetCollection() makoto.MigrateCollection {
	statements := []makoto.MigrateStatement{
	`)

	collection := processMigrationCollection(path)
	migration := collection.Head()
	for {
		st := migration.Statement()
		upSt, _ := json.Marshal(st.UpStatement)
		downSt, _ := json.Marshal(st.DownStatement)

		fmt.Fprintf(buffer, `
		{"%v", "%v", %v, %v, "%v"},
		`, st.Version, st.Filename, string(upSt), string(downSt), st.Checksum)

		fmt.Printf("%v\n", st.Filename)

		if migration.Next() != nil {
			migration = migration.Next()
			continue
		}
		break
	}

	fmt.Fprint(buffer, `
	}

	collection := makoto.MigrationCollection{}
	for _, st := range statements {
		collection.Add(statement)
	}
	return &collection
}`)

	dest := filepath.Join(path, collectionFilename)
	if err := ioutil.WriteFile(dest, buffer.Bytes(), 0644); err != nil {
		panic(err)
	}
}

func GenerateEmbedCollection(path string) {
	fmt.Println("Collect migration scripts with embed:")

	buffer := bytes.NewBuffer(nil)
	fmt.Fprint(buffer, `// this is generated by makoto cli, do not modify this file.
package migration

import (
	_ "embed"
	"path"
	"github.com/stanlry/makoto"
)

//go:embed sql/*.sql
var content embed.FS

func getAllFilename(fs *embed.FS, dir string) (out []string, err error) {
	if len(dir) == 0 {
		dir = "."
	}

	entries, err := fs.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		fp := path.Join(dir, entry.Name())
		if entry.IsDir() {
			res, err := getAllFilenames(fs, fp)
			if err != nil {
				return nil, err
			}

			out = append(out, res...)

			continue
		}

		out = append(out, fp)
	}

	return
}

func GetCollection() &makoto.MigrationCollection {
	files, err := getAllFilenames(content, "")
	if err != nil {
		panic(err)
	}

	collection := makoto.MigrationCollection{}
	for _, fname := range fnames {
		data, err := content.ReadFile(fname)
		if err != nil {
			panic(err)
		}
		reader := bytes.NewReader(data)
		statement := makoto.ParseMigrationStatement(reader)
		collection.Add(statement)
	}

	return &collection
}`)

	dest := filepath.Join(path, collectionFilename)
	if err := ioutil.WriteFile(dest, buffer.Bytes(), 0644); err != nil {
		panic(err)
	}
}
